# Implement LangGraph-based Meal Planning Workflow

This issue tracks the implementation of the KondateAgent meal planning system using the LangGraph framework, as researched in the LangGraphResearch.md documentation.

## Overview

LangGraph provides the ideal framework for building our stateful, iterative meal planning workflow with:
- Graph-based workflow orchestration
- Cyclic workflows for feedback loops
- Built-in persistence for session management
- Human-in-the-loop support
- OpenAI/ChatGPT integration
- Real-time streaming capabilities

## Implementation Roadmap

### Phase 1: Core Workflow (Foundation)

#### 1.1 Project Structure Setup
- [ ] Create LangGraph workflow module structure
- [ ] Define state schema with TypedDict
- [ ] Set up FastAPI endpoints for workflow execution
- [ ] Configure development environment and dependencies

**Dependencies:**
```bash
pip install langgraph langchain langchain-openai
pip install langgraph-checkpoint-sqlite
pip install fastapi uvicorn python-dotenv
```

#### 1.2 Implement Basic Nodes
- [ ] **Ingredient Parser Node**: ChatGPT NLU for extracting ingredients from user input
- [ ] **Basic Recipe Search Node**: Mock data initially, structure for real API integration
- [ ] **Meal Plan Generator Node**: ChatGPT-powered meal plan creation
- [ ] Wire nodes together with basic linear flow

#### 1.3 Add Persistence
- [ ] Integrate SqliteSaver for development checkpointing
- [ ] Implement session management with thread_id
- [ ] Test state persistence across workflow interruptions

**Deliverables:**
- Working linear workflow from ingredient input to meal plan
- Basic FastAPI endpoints for invocation
- Persistent session state

---

### Phase 2: External Integrations

#### 2.1 Recipe Sources
- [ ] **YouTube Data API Integration**
  - API client setup
  - Recipe metadata extraction
  - Thumbnail and video link retrieval
- [ ] **Instagram Graph API Integration**
  - API authentication
  - Recipe post parsing
  - Fallback web scraping if needed
- [ ] **Coverage Score Algorithm**
  - Calculate percentage of ingredients already available
  - Rank recipes by coverage score
  - Consider ingredient substitutability

#### 2.2 Streaming
- [ ] Enable token streaming for meal plan generation
- [ ] Implement Server-Sent Events (SSE) endpoints for frontend
- [ ] Add streaming progress indicators for recipe search
- [ ] Test real-time UI updates

**Deliverables:**
- Live recipe data from YouTube and Instagram
- Real-time streaming responses to frontend
- Coverage-based recipe ranking

---

### Phase 3: Feedback Loop

#### 3.1 Human-in-the-Loop
- [ ] Implement interrupt() for feedback collection
- [ ] Add conditional edges for plan regeneration
- [ ] Create routing logic based on feedback type:
  - "looks_good" → proceed to shopping list
  - "dont_like" / "not_in_mood" → regenerate plan
  - Custom feedback → incorporate into regeneration
- [ ] Implement iteration limits (max 3 cycles)

#### 3.2 Shopping List Optimization
- [ ] Calculate missing ingredients across meal plan
- [ ] Group ingredients by category (produce, protein, dairy, pantry)
- [ ] Prioritize recipes that share common ingredients
- [ ] Generate checkable shopping list with quantities

**Deliverables:**
- Working feedback cycle for meal plan refinement
- Optimized shopping list generation
- Max iteration safeguards

---

### Phase 4: Production Readiness

#### 4.1 Database Migration
- [ ] Migrate from SqliteSaver to PostgresSaver
- [ ] Set up production PostgreSQL database
- [ ] Add user authentication (JWT tokens)
- [ ] Store user preferences:
  - Favorite recipe sources
  - Dietary restrictions
  - Previous meal plans

#### 4.2 Deployment
- [ ] Create Dockerfile for containerization
- [ ] Configure Gunicorn + Uvicorn workers
- [ ] Set up environment variable management
- [ ] Configure CORS for frontend integration
- [ ] Deploy to production environment

#### 4.3 Monitoring and Optimization
- [ ] Integrate LangSmith for workflow observability
- [ ] Add comprehensive error handling and retries
- [ ] Implement rate limiting (API protection)
- [ ] Add caching for recipe searches
- [ ] Set up logging and alerting

**Deliverables:**
- Production-ready deployment
- User authentication and profiles
- Monitoring and observability
- Rate limiting and caching

---

## State Schema

The workflow will use the following state schema:

```python
class KondateState(TypedDict):
    # User session
    user_id: str

    # Conversation
    messages: Annotated[List[AnyMessage], add_messages]

    # Inputs
    raw_ingredients_input: str
    ingredients: List[Ingredient]
    dietary_restrictions: List[str]
    recipe_sources: List[dict]

    # Recipe candidates
    recipe_candidates: List[Recipe]

    # Meal plan
    current_meal_plan: List[DayMeal]

    # Feedback loop
    user_feedback: Optional[str]
    feedback_history: Annotated[List[str], operator.add]
    iteration_count: int

    # Output
    shopping_list: List[ShoppingItem]
    plan_finalized: bool
```

## Workflow Architecture

```
START → Parse Ingredients → Search Recipes → Generate Meal Plan
                                                      ↓
                                            Wait for Feedback
                                                      ↓
                                            Process Feedback
                                                   ↙     ↘
                                         "regenerate"  "finalize"
                                              ↓            ↓
                                    (back to Generate)  Shopping List → END
```

## Success Criteria

- [ ] Users can input ingredients via chat interface
- [ ] System searches YouTube and Instagram for relevant recipes
- [ ] AI generates optimized weekly meal plan
- [ ] Users can provide feedback and trigger plan regeneration
- [ ] System produces minimal shopping list
- [ ] Sessions persist across interruptions
- [ ] Real-time streaming updates to frontend
- [ ] Production deployment with authentication

## Technical References

- [LangGraph Documentation](https://docs.langchain.com/oss/python/langgraph/overview)
- LangGraphResearch.md in Docs folder
- CLAUDE.md - Project guidelines

## Notes

- Start with Phase 1 to establish foundation
- Each phase builds on previous phases
- Mock external APIs initially, then integrate real data
- Prioritize user feedback loop as core differentiator
- Keep deployment considerations in mind from the start

---

Related to PR #2
